"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtensionsEmulator = void 0;
const fs = require("fs-extra");
const os = require("os");
const path = require("path");
const clc = require("cli-color");
const Table = require("cli-table");
const child_process_1 = require("child_process");
const planner = require("../deploy/extensions/planner");
const error_1 = require("../error");
const refs_1 = require("../extensions/refs");
const download_1 = require("./download");
const optionsHelper_1 = require("../extensions/emulator/optionsHelper");
const emulatorLogger_1 = require("./emulatorLogger");
const types_1 = require("./types");
const validation_1 = require("./extensions/validation");
const ensureApiEnabled_1 = require("../ensureApiEnabled");
const shortenUrl_1 = require("../shortenUrl");
const constants_1 = require("./constants");
class ExtensionsEmulator {
    constructor(args) {
        this.want = [];
        this.logger = emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.EXTENSIONS);
        this.pendingDownloads = new Map();
        this.args = args;
    }
    async readManifest() {
        var _a;
        this.want = await planner.want({
            projectId: this.args.projectId,
            projectNumber: this.args.projectNumber,
            aliases: (_a = this.args.aliases) !== null && _a !== void 0 ? _a : [],
            projectDir: this.args.projectDir,
            extensions: this.args.extensions,
            emulatorMode: true,
        });
    }
    async ensureSourceCode(instance) {
        if (!instance.ref) {
            throw new error_1.FirebaseError(`No ref found for ${instance.instanceId}. Emulating local extensions is not yet supported.`);
        }
        const ref = (0, refs_1.toExtensionVersionRef)(instance.ref);
        const cacheDir = process.env.FIREBASE_EXTENSIONS_CACHE_PATH ||
            path.join(os.homedir(), ".cache", "firebase", "extensions");
        const sourceCodePath = path.join(cacheDir, ref);
        if (this.pendingDownloads.get(ref)) {
            await this.pendingDownloads.get(ref);
        }
        if (!this.hasValidSource({ path: sourceCodePath, extRef: ref })) {
            const promise = this.downloadSource(instance, ref, sourceCodePath);
            this.pendingDownloads.set(ref, promise);
            await promise;
        }
        return sourceCodePath;
    }
    async downloadSource(instance, ref, sourceCodePath) {
        const extensionVersion = await planner.getExtensionVersion(instance);
        await (0, download_1.downloadExtensionVersion)(ref, extensionVersion.sourceDownloadUri, sourceCodePath);
        this.installAndBuildSourceCode(sourceCodePath);
    }
    hasValidSource(args) {
        const requiredFiles = [
            "./extension.yaml",
            "./functions/package.json",
            "./functions/node_modules",
        ];
        if (!fs.existsSync(args.path)) {
            return false;
        }
        for (const requiredFile of requiredFiles) {
            const f = path.join(args.path, requiredFile);
            if (!fs.existsSync(f)) {
                emulatorLogger_1.EmulatorLogger.forExtension({ ref: args.extRef }).logLabeled("BULLET", "extensions", `Detected invalid source code for ${args.extRef}, expected to find ${f}`);
                return false;
            }
        }
        return true;
    }
    installAndBuildSourceCode(sourceCodePath) {
        const npmInstall = (0, child_process_1.spawnSync)("npm", ["--prefix", `/${sourceCodePath}/functions/`, "install"], {
            encoding: "utf8",
        });
        if (npmInstall.error) {
            throw npmInstall.error;
        }
        const npmRunGCPBuild = (0, child_process_1.spawnSync)("npm", ["--prefix", `/${sourceCodePath}/functions/`, "run", "gcp-build"], { encoding: "utf8" });
        if (npmRunGCPBuild.error) {
            throw npmRunGCPBuild.error;
        }
    }
    async getExtensionBackends() {
        await this.readManifest();
        await this.checkAndWarnAPIs(this.want);
        return Promise.all(this.want.map((i) => {
            return this.toEmulatableBackend(i);
        }));
    }
    async toEmulatableBackend(instance) {
        const extensionDir = await this.ensureSourceCode(instance);
        const functionsDir = path.join(extensionDir, "functions");
        const env = Object.assign(this.autoPopulatedParams(instance), instance.params);
        const { extensionTriggers, nodeMajorVersion, nonSecretEnv, secretEnvVariables } = await (0, optionsHelper_1.getExtensionFunctionInfo)(extensionDir, instance.instanceId, env);
        const extension = await planner.getExtension(instance);
        const extensionVersion = await planner.getExtensionVersion(instance);
        return {
            functionsDir,
            env: nonSecretEnv,
            secretEnv: secretEnvVariables,
            predefinedTriggers: extensionTriggers,
            nodeMajorVersion: nodeMajorVersion,
            extensionInstanceId: instance.instanceId,
            extension,
            extensionVersion,
        };
    }
    autoPopulatedParams(instance) {
        const projectId = this.args.projectId;
        return {
            PROJECT_ID: projectId !== null && projectId !== void 0 ? projectId : "",
            EXT_INSTANCE_ID: instance.instanceId,
            DATABASE_INSTANCE: projectId !== null && projectId !== void 0 ? projectId : "",
            DATABASE_URL: `https://${projectId}.firebaseio.com`,
            STORAGE_BUCKET: `${projectId}.appspot.com`,
        };
    }
    async checkAndWarnAPIs(instances) {
        const apisToWarn = await (0, validation_1.getUnemulatedAPIs)(this.args.projectId, instances);
        if (apisToWarn.length) {
            const table = new Table({
                head: [
                    "API Name",
                    "Instances using this API",
                    `Enabled on ${this.args.projectId}`,
                    `Enable this API`,
                ],
                style: { head: ["yellow"] },
            });
            for (const apiToWarn of apisToWarn) {
                const enablementUri = await (0, shortenUrl_1.shortenUrl)((0, ensureApiEnabled_1.enableApiURI)(this.args.projectId, apiToWarn.apiName));
                table.push([
                    apiToWarn.apiName,
                    apiToWarn.instanceIds,
                    apiToWarn.enabled ? "Yes" : "No",
                    apiToWarn.enabled ? "" : clc.bold.underline(enablementUri),
                ]);
            }
            if (constants_1.Constants.isDemoProject(this.args.projectId)) {
                this.logger.logLabeled("WARN", "Extensions", "The following Extensions make calls to Google Cloud APIs that do not have Emulators. " +
                    `${clc.bold(this.args.projectId)} is a demo project, so these Extensions may not work as expected.\n` +
                    table.toString());
            }
            else {
                this.logger.logLabeled("WARN", "Extensions", "The following Extensions make calls to Google Cloud APIs that do not have Emulators. " +
                    `These calls will go to production Google Cloud APIs which may have real effects on ${clc.bold(this.args.projectId)}.\n` +
                    table.toString());
            }
        }
    }
    filterUnemulatedTriggers(options, backends) {
        let foundUnemulatedTrigger = false;
        const filteredBackends = backends.filter((backend) => {
            const unemulatedServices = (0, validation_1.checkForUnemulatedTriggerTypes)(backend, options);
            if (unemulatedServices.length) {
                foundUnemulatedTrigger = true;
                const msg = ` ignored becuase it includes ${unemulatedServices.join(", ")} triggered functions, and the ${unemulatedServices.join(", ")} emulator does not exist or is not running.`;
                this.logger.logLabeled("WARN", `extensions[${backend.extensionInstanceId}]`, msg);
            }
            return unemulatedServices.length === 0;
        });
        if (foundUnemulatedTrigger) {
            const msg = "No Cloud Functions for these instances will be emulated, because partially emulating an Extension can lead to unexpected behavior. ";
            this.logger.log("WARN", msg);
        }
        return filteredBackends;
    }
}
exports.ExtensionsEmulator = ExtensionsEmulator;
