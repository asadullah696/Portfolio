"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.secretsAreValid = exports.functionIdsAreValid = exports.functionsDirectoryExists = exports.endpointsAreValid = void 0;
const path = require("path");
const clc = require("cli-color");
const error_1 = require("../../error");
const secretManager_1 = require("../../gcp/secretManager");
const logger_1 = require("../../logger");
const fsutils = require("../../fsutils");
const backend = require("./backend");
const utils = require("../../utils");
const secrets = require("../../functions/secrets");
function endpointsAreValid(wantBackend) {
    functionIdsAreValid(backend.allEndpoints(wantBackend));
    const gcfV1WithConcurrency = backend
        .allEndpoints(wantBackend)
        .filter((endpoint) => (endpoint.concurrency || 1) !== 1 && endpoint.platform === "gcfv1")
        .map((endpoint) => endpoint.id);
    if (gcfV1WithConcurrency.length) {
        const msg = `Cannot set concurrency on the functions ${gcfV1WithConcurrency.join(",")} because they are GCF gen 1`;
        throw new error_1.FirebaseError(msg);
    }
    const tooSmallForConcurrency = backend
        .allEndpoints(wantBackend)
        .filter((endpoint) => {
        if ((endpoint.concurrency || 1) === 1) {
            return false;
        }
        const mem = endpoint.availableMemoryMb || backend.DEFAULT_MEMORY;
        return mem < backend.MIN_MEMORY_FOR_CONCURRENCY;
    })
        .map((endpoint) => endpoint.id);
    if (tooSmallForConcurrency.length) {
        const msg = `Cannot set concurency on the functions ${tooSmallForConcurrency.join(",")} because they have fewer than 2GB memory`;
        throw new error_1.FirebaseError(msg);
    }
}
exports.endpointsAreValid = endpointsAreValid;
function functionsDirectoryExists(sourceDir, projectDir) {
    if (!fsutils.dirExistsSync(sourceDir)) {
        const sourceDirName = path.relative(projectDir, sourceDir);
        const msg = `could not deploy functions because the ${clc.bold('"' + sourceDirName + '"')} ` +
            `directory was not found. Please create it or specify a different source directory in firebase.json`;
        throw new error_1.FirebaseError(msg);
    }
}
exports.functionsDirectoryExists = functionsDirectoryExists;
function functionIdsAreValid(functions) {
    const v1FunctionName = /^[a-zA-Z][a-zA-Z0-9_-]{0,62}$/;
    const invalidV1Ids = functions.filter((fn) => {
        return fn.platform === "gcfv1" && !v1FunctionName.test(fn.id);
    });
    if (invalidV1Ids.length !== 0) {
        const msg = `${invalidV1Ids.map((f) => f.id).join(", ")} function name(s) can only contain letters, ` +
            `numbers, hyphens, and not exceed 62 characters in length`;
        throw new error_1.FirebaseError(msg);
    }
    const v2FunctionName = /^[a-z][a-z0-9-]{0,62}$/;
    const invalidV2Ids = functions.filter((fn) => {
        return fn.platform === "gcfv2" && !v2FunctionName.test(fn.id);
    });
    if (invalidV2Ids.length !== 0) {
        const msg = `${invalidV2Ids.map((f) => f.id).join(", ")} v2 function name(s) can only contin lower ` +
            `case letters, numbers, hyphens, and not exceed 62 characters in length`;
        throw new error_1.FirebaseError(msg);
    }
}
exports.functionIdsAreValid = functionIdsAreValid;
async function secretsAreValid(projectId, wantBackend) {
    const endpoints = backend
        .allEndpoints(wantBackend)
        .filter((e) => e.secretEnvironmentVariables && e.secretEnvironmentVariables.length > 0);
    validatePlatformTargets(endpoints);
    await validateSecretVersions(projectId, endpoints);
}
exports.secretsAreValid = secretsAreValid;
function validatePlatformTargets(endpoints) {
    const supportedPlatforms = ["gcfv1"];
    const unsupported = endpoints.filter((e) => !supportedPlatforms.includes(e.platform));
    if (unsupported.length > 0) {
        const errs = unsupported.map((e) => `${e.id}[platform=${e.platform}]`);
        throw new error_1.FirebaseError(`Tried to set secret environment variables on ${errs.join(", ")}. ` +
            `Only ${supportedPlatforms.join(", ")} support secret environments.`);
    }
}
async function validateSecretVersions(projectId, endpoints) {
    const toResolve = new Set();
    for (const s of secrets.of(endpoints)) {
        toResolve.add(s.secret);
    }
    const results = await utils.allSettled(Array.from(toResolve).map(async (secret) => {
        const sv = await (0, secretManager_1.getSecretVersion)(projectId, secret, "latest");
        logger_1.logger.debug(`Resolved secret version of ${clc.bold(secret)} to ${clc.bold(sv.versionId)}.`);
        return sv;
    }));
    const secretVersions = {};
    const errs = [];
    for (const result of results) {
        if (result.status === "fulfilled") {
            const sv = result.value;
            if (sv.state !== "ENABLED") {
                errs.push(new error_1.FirebaseError(`Expected secret ${sv.secret.name}@${sv.versionId} to be in state ENABLED not ${sv.state}.`));
            }
            secretVersions[sv.secret.name] = sv;
        }
        else {
            errs.push(new error_1.FirebaseError(result.reason.message));
        }
    }
    if (errs.length) {
        throw new error_1.FirebaseError("Failed to validate secret versions", { children: errs });
    }
    for (const s of secrets.of(endpoints)) {
        s.version = secretVersions[s.secret].versionId;
        if (!s.version) {
            throw new error_1.FirebaseError("Secret version is unexpectedly undefined. This should never happen.");
        }
    }
}
