"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addResourcesToBackend = exports.mergeRequiredAPIs = exports.discoverBackend = exports.useStrategy = void 0;
const path = require("path");
const _ = require("lodash");
const child_process_1 = require("child_process");
const error_1 = require("../../../../error");
const logger_1 = require("../../../../logger");
const backend = require("../../backend");
const api = require("../../../../api");
const proto = require("../../../../gcp/proto");
const v2events = require("../../../../functions/events/v2");
const TRIGGER_PARSER = path.resolve(__dirname, "./triggerParser.js");
function removeInspectOptions(options) {
    return options.filter((opt) => !opt.startsWith("--inspect"));
}
function parseTriggers(projectId, sourceDir, configValues, envs) {
    return new Promise((resolve, reject) => {
        const env = Object.assign({}, envs);
        env.GCLOUD_PROJECT = projectId;
        if (!_.isEmpty(configValues)) {
            env.CLOUD_RUNTIME_CONFIG = JSON.stringify(configValues);
        }
        const execArgv = removeInspectOptions(process.execArgv);
        if (env.NODE_OPTIONS) {
            env.NODE_OPTIONS = removeInspectOptions(env.NODE_OPTIONS.split(" ")).join(" ");
        }
        const parser = (0, child_process_1.fork)(TRIGGER_PARSER, [sourceDir], {
            silent: true,
            env: env,
            execArgv: execArgv,
        });
        parser.on("message", (message) => {
            if (message.triggers) {
                resolve(message.triggers);
            }
            else if (message.error) {
                reject(new error_1.FirebaseError(message.error, { exit: 1 }));
            }
        });
        parser.on("exit", (code) => {
            if (code !== 0) {
                reject(new error_1.FirebaseError("There was an unknown problem while trying to parse function triggers.", { exit: 2 }));
            }
        });
    });
}
function useStrategy(context) {
    return Promise.resolve(true);
}
exports.useStrategy = useStrategy;
async function discoverBackend(projectId, sourceDir, runtime, configValues, envs) {
    const triggerAnnotations = await parseTriggers(projectId, sourceDir, configValues, envs);
    const want = Object.assign(Object.assign({}, backend.empty()), { environmentVariables: envs });
    for (const annotation of triggerAnnotations) {
        addResourcesToBackend(projectId, runtime, annotation, want);
    }
    return want;
}
exports.discoverBackend = discoverBackend;
function mergeRequiredAPIs(backend) {
    const apiToReasons = {};
    for (const { api, reason } of backend.requiredAPIs) {
        const reasons = apiToReasons[api] || new Set();
        reasons.add(reason);
        apiToReasons[api] = reasons;
    }
    const merged = [];
    for (const [api, reasons] of Object.entries(apiToReasons)) {
        merged.push({ api, reason: Array.from(reasons).join(" ") });
    }
    backend.requiredAPIs = merged;
}
exports.mergeRequiredAPIs = mergeRequiredAPIs;
function addResourcesToBackend(projectId, runtime, annotation, want) {
    var _a;
    Object.freeze(annotation);
    for (const region of annotation.regions || [api.functionsDefaultRegion]) {
        let triggered;
        const triggerCount = +!!annotation.httpsTrigger + +!!annotation.eventTrigger + +!!annotation.taskQueueTrigger;
        if (triggerCount !== 1) {
            throw new error_1.FirebaseError("Unexpected annotation generated by the Firebase Functions SDK. This should never happen.");
        }
        if (annotation.taskQueueTrigger) {
            triggered = { taskQueueTrigger: annotation.taskQueueTrigger };
            want.requiredAPIs.push({
                api: "cloudtasks.googleapis.com",
                reason: "Needed for task queue functions.",
            });
        }
        else if (annotation.httpsTrigger) {
            if ((_a = annotation.labels) === null || _a === void 0 ? void 0 : _a["deployment-callable"]) {
                delete annotation.labels["deployment-callable"];
                triggered = { callableTrigger: {} };
            }
            else {
                const trigger = {};
                if (annotation.failurePolicy) {
                    logger_1.logger.warn(`Ignoring retry policy for HTTPS function ${annotation.name}`);
                }
                proto.copyIfPresent(trigger, annotation.httpsTrigger, "invoker");
                triggered = { httpsTrigger: trigger };
            }
        }
        else if (annotation.schedule) {
            want.requiredAPIs.push({
                api: "cloudscheduler.googleapis.com",
                reason: "Needed for scheduled functions.",
            });
            triggered = { scheduleTrigger: annotation.schedule };
        }
        else {
            triggered = {
                eventTrigger: {
                    eventType: annotation.eventTrigger.eventType,
                    eventFilters: { resource: annotation.eventTrigger.resource },
                    retry: !!annotation.failurePolicy,
                },
            };
            if (annotation.platform === "gcfv2") {
                if (annotation.eventTrigger.eventType === v2events.PUBSUB_PUBLISH_EVENT) {
                    triggered.eventTrigger.eventFilters = { topic: annotation.eventTrigger.resource };
                }
                if (v2events.STORAGE_EVENTS.find((event) => { var _a; return event === (((_a = annotation.eventTrigger) === null || _a === void 0 ? void 0 : _a.eventType) || ""); })) {
                    triggered.eventTrigger.eventFilters = { bucket: annotation.eventTrigger.resource };
                }
            }
        }
        const endpoint = Object.assign({ platform: annotation.platform || "gcfv1", id: annotation.name, region: region, project: projectId, entryPoint: annotation.entryPoint, runtime: runtime }, triggered);
        if (annotation.vpcConnector != null) {
            let maybeId = annotation.vpcConnector;
            if (maybeId && !maybeId.includes("/")) {
                maybeId = `projects/${projectId}/locations/${region}/connectors/${maybeId}`;
            }
            endpoint.vpc = { connector: maybeId };
            proto.renameIfPresent(endpoint.vpc, annotation, "egressSettings", "vpcConnectorEgressSettings");
        }
        if (annotation.secrets) {
            const secretEnvs = [];
            for (const secret of annotation.secrets) {
                const secretEnv = {
                    secret,
                    projectId,
                    key: secret,
                };
                secretEnvs.push(secretEnv);
            }
            endpoint.secretEnvironmentVariables = secretEnvs;
        }
        proto.copyIfPresent(endpoint, annotation, "concurrency", "serviceAccountEmail", "labels", "ingressSettings", "maxInstances", "minInstances", "availableMemoryMb");
        proto.renameIfPresent(endpoint, annotation, "timeoutSeconds", "timeout", proto.secondsFromDuration);
        want.endpoints[region] = want.endpoints[region] || {};
        want.endpoints[region][endpoint.id] = endpoint;
        mergeRequiredAPIs(want);
    }
}
exports.addResourcesToBackend = addResourcesToBackend;
